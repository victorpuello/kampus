from __future__ import annotations

import uuid

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.validators import FileExtensionValidator
from django.db import models
from django.db.models import Q
from django.utils import timezone


class AttendanceSession(models.Model):
    teacher_assignment = models.ForeignKey(
        "academic.TeacherAssignment",
        on_delete=models.CASCADE,
        related_name="attendance_sessions",
    )
    period = models.ForeignKey(
        "academic.Period",
        on_delete=models.CASCADE,
        related_name="attendance_sessions",
    )

    # Local calendar date for reporting/uniqueness.
    class_date = models.DateField(default=timezone.localdate)

    # When the teacher created/started the class. Defaults to now.
    starts_at = models.DateTimeField(default=timezone.now)

    # Sequence number for multiple classes on same date.
    sequence = models.PositiveSmallIntegerField(default=1)

    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="attendance_sessions_created",
    )

    # Idempotency key generated by the frontend to avoid duplicates on double submit.
    client_uuid = models.UUIDField(null=True, blank=True)

    locked_at = models.DateTimeField(null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["teacher_assignment", "period", "class_date", "sequence"],
                name="uniq_attendance_session_assignment_period_date_seq",
            ),
            models.UniqueConstraint(
                fields=["created_by", "client_uuid"],
                condition=Q(client_uuid__isnull=False),
                name="uniq_attendance_session_created_by_client_uuid",
            ),
        ]
        indexes = [
            models.Index(fields=["teacher_assignment", "class_date"], name="idx_att_sess_ta_date"),
            models.Index(fields=["period", "class_date"], name="idx_att_sess_period_date"),
        ]
        ordering = ["-starts_at", "-id"]

    def clean(self):
        super().clean()
        if self.teacher_assignment_id and self.period_id:
            try:
                ta_year = self.teacher_assignment.academic_year_id
                period_year = self.period.academic_year_id
                if ta_year != period_year:
                    raise ValidationError("La clase debe pertenecer al mismo año académico del periodo.")
            except Exception:
                # Avoid blocking save due to missing relations on partial state.
                pass

    def __str__(self) -> str:
        return f"AttendanceSession {self.id} ({self.teacher_assignment_id}) {self.class_date} #{self.sequence}"


class AttendanceRecord(models.Model):
    STATUS_PRESENT = "PRESENT"
    STATUS_ABSENT = "ABSENT"
    STATUS_TARDY = "TARDY"
    STATUS_EXCUSED = "EXCUSED"

    STATUS_CHOICES = (
        (STATUS_PRESENT, "Presente"),
        (STATUS_ABSENT, "Ausente"),
        (STATUS_TARDY, "Tarde"),
        (STATUS_EXCUSED, "Excusa"),
    )

    session = models.ForeignKey(
        AttendanceSession,
        on_delete=models.CASCADE,
        related_name="records",
    )
    enrollment = models.ForeignKey(
        "students.Enrollment",
        on_delete=models.CASCADE,
        related_name="attendance_records",
    )

    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default=STATUS_PRESENT)

    # Automatic timestamp set by the system when marking TARDY.
    tardy_at = models.DateTimeField(null=True, blank=True)

    excuse_reason = models.TextField(blank=True)
    excuse_attachment = models.FileField(
        upload_to="attendance/excuses/%Y/%m/%d/",
        null=True,
        blank=True,
        validators=[FileExtensionValidator(["pdf", "png", "jpg", "jpeg"])],
    )

    marked_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="attendance_records_marked",
    )

    marked_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["session", "enrollment"],
                name="uniq_attendance_record_session_enrollment",
            ),
        ]
        indexes = [
            models.Index(fields=["enrollment", "status"], name="idx_att_rec_enroll_status"),
            models.Index(fields=["session", "status"], name="idx_att_rec_session_status"),
        ]

    def clean(self):
        super().clean()

        if self.status == self.STATUS_EXCUSED:
            if not self.excuse_reason and not self.excuse_attachment:
                raise ValidationError("La excusa requiere un motivo o un soporte adjunto.")

        if self.status == self.STATUS_TARDY:
            if not self.tardy_at:
                raise ValidationError("El registro de tardanza requiere hora de ingreso (tardy_at).")

    def apply_status(self, *, status: str, user=None, now=None, excuse_reason: str | None = None):
        now = now or timezone.now()
        self.status = status
        self.marked_by = user

        if status == self.STATUS_TARDY:
            # Always set automatically.
            self.tardy_at = now
        else:
            self.tardy_at = None

        if status == self.STATUS_EXCUSED and excuse_reason is not None:
            self.excuse_reason = excuse_reason

    def __str__(self) -> str:
        return f"AttendanceRecord {self.id} ({self.enrollment_id}) {self.status}"
